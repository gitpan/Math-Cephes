/*
 * FILE : Cephes_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Build 883)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* $Header: /cvsroot/SWIG1.1/swig_lib/perl5/headers.swg,v 1.1.1.1 1999/02/28 02:00:54 beazley Exp $ */
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a) __declspec(dllexport) a
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a) a _export 
#	else
#	    define SWIGEXPORT(a) a 
#	endif
#   endif
#else
#   define SWIGEXPORT(a) a 
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
#define MAGIC_CAST   (int (CPerlObj::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

/******************************************************************************
 * Pointer type-checking code
 *****************************************************************************/

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE
extern void SWIG_MakePtr(char *, void *, char *);
#ifndef PERL_OBJECT
extern void SWIG_RegisterMapping(char *, char *, void *(*)(void *));
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl,a,b,c);
extern void _SWIG_RegisterMapping(CPerlObj *,char *, char *, void *(*)(void *),int);
#endif
#ifndef PERL_OBJECT
extern char *SWIG_GetPtr(SV *, void **, char *);
#else
extern char *_SWIG_GetPtr(CPerlObj *, SV *, void **, char *);
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
#endif

#else

#ifdef SWIG_GLOBAL
#define SWIGSTATICRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGSTATICRUNTIME(a) static a
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(void) 
SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
SWIGSTATICRUNTIME(void)
_SWIG_RegisterMapping(CPerlObj *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATICRUNTIME(void) 
SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(char *) 
SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
SWIGSTATICRUNTIME(char *)
_SWIG_GetPtr(CPerlObj *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start > end) sp = 0;
      while (start <= end) {
	if (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	}
	sp++;
	start++;
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

#endif
#ifdef __cplusplus
}
#endif






/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_Math__Cephes

#define SWIG_name   "Cephes::boot_Math__Cephes"
#define SWIG_varinit "Cephes::var_Math__Cephes_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void) boot_Math__Cephes(CV* cv);
#else
SWIGEXPORT(void) boot_Math__Cephes(CV *cv, CPerlObj *);
#endif

typedef struct {
    double n;
    double d;
} fract;

typedef struct {
    double r;
    double i;
} cmplx;
extern double  MACHEP; 
extern double  MAXLOG; 
extern double  MINLOG; 
extern double  MAXNUM; 
extern double  PI; 
extern double  PIO2; 
extern double  PIO4; 
extern double  SQRT2; 
extern double  SQRTH; 
extern double  LOG2E; 
extern double  SQ2OPI; 
extern double  LOGE2; 
extern double  LOGSQ2; 
extern double  THPIO4; 
extern double  TWOOPI; 
extern double acosh(double );
extern int airy(double ,double *,double *,double *,double *);
extern double asin(double );
extern double acos(double );
extern double asinh(double );
extern double atan(double );
extern double atan2(double ,double );
extern double atanh(double );
extern double bdtrc(int ,int ,double );
extern double bdtr(int ,int ,double );
extern double bdtri(int ,int ,double );
extern double beta(double ,double );
extern double lbeta(double ,double );
extern double btdtr(double ,double ,double );
extern double cbrt(double );
extern double chbevl(double ,void *,int );
extern double chdtrc(double ,double );
extern double chdtr(double ,double );
extern double chdtri(double ,double );
extern void clog(cmplx *,cmplx *);
extern void cexp(cmplx *,cmplx *);
extern void csin(cmplx *,cmplx *);
extern void ccos(cmplx *,cmplx *);
extern void ctan(cmplx *,cmplx *);
extern void ccot(cmplx *,cmplx *);
extern void casin(cmplx *,cmplx *);
extern void cacos(cmplx *,cmplx *);
extern void catan(cmplx *,cmplx *);
extern void csinh(cmplx *,cmplx *);
extern void casinh(cmplx *,cmplx *);
extern void ccosh(cmplx *,cmplx *);
extern void cacosh(cmplx *,cmplx *);
extern void ctanh(cmplx *,cmplx *);
extern void catanh(cmplx *,cmplx *);
extern void cpow(cmplx *,cmplx *,cmplx *);
extern void radd(fract *,fract *,fract *);
extern void rsub(fract *,fract *,fract *);
extern void rmul(fract *,fract *,fract *);
extern void rdiv(fract *,fract *,fract *);
extern double euclid(double *,double *);
extern void cadd(cmplx *,cmplx *,cmplx *);
extern void csub(cmplx *,cmplx *,cmplx *);
extern void cmul(cmplx *,cmplx *,cmplx *);
extern void cdiv(cmplx *,cmplx *,cmplx *);
extern void cmov(void *,void *);
extern void cneg(cmplx *);
extern double cabs(cmplx *);
extern void csqrt(cmplx *,cmplx *);
extern double hypot(double ,double );
extern double cosh(double );
extern double dawsn(double );
extern double ellie(double ,double );
extern double ellik(double ,double );
extern double ellpe(double );
extern int ellpj(double ,double ,double *,double *,double *,double *);
extern double ellpk(double );
extern double exp(double );
extern double exp10(double );
extern double exp2(double );
extern double expn(int ,double );
extern double ei(double );
extern double fabs(double );
extern double fac(int );
extern double fdtrc(int ,int ,double );
extern double fdtr(int ,int ,double );
extern double fdtri(int ,int ,double );
extern double ceil(double );
extern double floor(double );
extern double frexp(double ,int *);
extern double ldexp(double ,int );
/* extern int signbit(double ); */
/* extern int isnan(double ); */
/* extern int isfinite(double ); */
extern int fresnl(double ,double *,double *);
extern double gamma(double );
extern double lgam(double );
extern double gdtr(double ,double ,double );
extern double gdtrc(double ,double ,double );
extern double hyp2f1(double ,double ,double ,double );
extern double hyperg(double ,double ,double );
extern double hyp2f0(double ,double ,double ,int ,double *);
extern double i0(double );
extern double i0e(double );
extern double i1(double );
extern double i1e(double );
extern double igamc(double ,double );
extern double igam(double ,double );
extern double igami(double ,double );
extern double incbet(double ,double ,double );
extern double incbi(double ,double ,double );
extern double iv(double ,double );
extern double j0(double );
extern double y0(double );
extern double j1(double );
extern double y1(double );
extern double jn(int ,double );
extern double jv(double ,double );
extern double k0(double );
extern double k0e(double );
extern double k1(double );
extern double k1e(double );
extern double kn(int ,double );
extern double log(double );
extern double log10(double );
extern double log2(double );
extern long lrand();
extern long lsqrt(long );
extern int mtherr(char *,int );
extern double polevl(double ,void *,int );
extern double p1evl(double ,void *,int );
extern double nbdtrc(int ,int ,double );
extern double nbdtr(int ,int ,double );
extern double nbdtri(int ,int ,double );
extern double ndtr(double );
extern double erfc(double );
extern double erf(double );
extern double ndtri(double );
extern double pdtrc(int ,double );
extern double pdtr(int ,double );
extern double pdtri(int ,double );
extern double pow(double ,double );
extern double powi(double ,int );
extern double psi(double );
extern double rgamma(double );
extern double round(double );
extern int shichi(double ,double *,double *);
extern int sici(double ,double *,double *);
extern double sin(double );
extern double cos(double );
extern double radian(double ,double ,double );
extern double sindg(double );
extern double cosdg(double );
extern double sinh(double );
extern double spence(double );
extern double sqrt(double );
extern double stdtr(int ,double );
extern double stdtri(int ,double );
extern double onef2(double ,double ,double ,double ,double *);
extern double threef0(double ,double ,double ,double ,double *);
extern double struve(double ,double );
extern double tan(double );
extern double cot(double );
extern double tandg(double );
extern double cotdg(double );
extern double tanh(double );
extern double log1p(double );
extern double expm1(double );
extern double cosm1(double );
extern double yn(int ,double );
extern double yv(double ,double );
extern double zeta(double ,double );
extern double zetac(double );
extern int drand(double *);
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_Math__Cephes_var::
class _wrap_Math__Cephes_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
/* SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) { */
/*     MAGIC_PPERL */
/*     sv = sv; mg = mg; */
/*     croak("Value is read-only."); */
/*     return 0; */
/* } */
SWIGCLASS_STATIC int _wrap_set_MACHEP(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    MACHEP = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_MACHEP(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) MACHEP);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_MAXLOG(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    MAXLOG = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_MAXLOG(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) MAXLOG);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_MINLOG(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    MINLOG = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_MINLOG(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) MINLOG);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_MAXNUM(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    MAXNUM = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_MAXNUM(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) MAXNUM);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_PI(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    PI = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_PI(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) PI);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_PIO2(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    PIO2 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_PIO2(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) PIO2);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_PIO4(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    PIO4 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_PIO4(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) PIO4);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_SQRT2(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    SQRT2 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_SQRT2(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) SQRT2);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_SQRTH(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    SQRTH = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_SQRTH(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) SQRTH);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_LOG2E(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    LOG2E = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_LOG2E(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) LOG2E);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_SQ2OPI(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    SQ2OPI = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_SQ2OPI(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) SQ2OPI);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_LOGE2(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    LOGE2 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_LOGE2(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) LOGE2);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_LOGSQ2(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    LOGSQ2 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_LOGSQ2(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) LOGSQ2);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_THPIO4(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    THPIO4 = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_THPIO4(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) THPIO4);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_TWOOPI(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    TWOOPI = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_TWOOPI(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) TWOOPI);
    return 1;
}



#ifdef PERL_OBJECT
};
#endif

XS(_wrap_acosh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: acosh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )acosh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_airy) {

    int  _result;
    double  _arg0;
    double * _arg1;
    double  temp;
    double * _arg2;
    double  temp0;
    double * _arg3;
    double  temp1;
    double * _arg4;
    double  temp2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg1 = &temp;
}
{
  _arg2 = &temp0;
}
{
  _arg3 = &temp1;
}
{
  _arg4 = &temp2;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: airy(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )airy(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg1));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg2));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg3));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_asin) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: asin(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )asin(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_acos) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: acos(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )acos(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_asinh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: asinh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )asinh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_atan) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: atan(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )atan(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_atan2) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: atan2(y,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )atan2(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_atanh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: atanh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )atanh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_bdtrc) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: bdtrc(k,n,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )bdtrc(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_bdtr) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: bdtr(k,n,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )bdtr(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_bdtri) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: bdtri(k,n,y);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )bdtri(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_beta) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: beta(a,b);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )beta(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_lbeta) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: lbeta(a,b);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )lbeta(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_btdtr) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: btdtr(a,b,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )btdtr(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cbrt) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cbrt(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cbrt(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_chbevl) {

    double  _result;
    double  _arg0;
    void * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: chbevl(x,P,n);");
    _arg0 = (double ) SvNV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of chbevl. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )chbevl(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_chdtrc) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: chdtrc(df,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )chdtrc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_chdtr) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: chdtr(df,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )chdtr(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_chdtri) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: chdtri(df,y);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )chdtri(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_clog) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: clog(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of clog. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of clog. Expected cmplx.");
        XSRETURN(1);
    }
    clog(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_cexp) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cexp(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cexp. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cexp. Expected cmplx.");
        XSRETURN(1);
    }
    cexp(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_csin) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: csin(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of csin. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of csin. Expected cmplx.");
        XSRETURN(1);
    }
    csin(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_ccos) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ccos(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of ccos. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of ccos. Expected cmplx.");
        XSRETURN(1);
    }
    ccos(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_ctan) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ctan(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of ctan. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of ctan. Expected cmplx.");
        XSRETURN(1);
    }
    ctan(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_ccot) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ccot(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of ccot. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of ccot. Expected cmplx.");
        XSRETURN(1);
    }
    ccot(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_casin) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: casin(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of casin. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of casin. Expected cmplx.");
        XSRETURN(1);
    }
    casin(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_cacos) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cacos(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cacos. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cacos. Expected cmplx.");
        XSRETURN(1);
    }
    cacos(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_catan) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: catan(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of catan. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of catan. Expected cmplx.");
        XSRETURN(1);
    }
    catan(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_csinh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: csinh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of csinh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of csinh. Expected cmplx.");
        XSRETURN(1);
    }
    csinh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_casinh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: casinh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of casinh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of casinh. Expected cmplx.");
        XSRETURN(1);
    }
    casinh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_ccosh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ccosh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of ccosh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of ccosh. Expected cmplx.");
        XSRETURN(1);
    }
    ccosh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_cacosh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cacosh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cacosh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cacosh. Expected cmplx.");
        XSRETURN(1);
    }
    cacosh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_ctanh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ctanh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of ctanh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of ctanh. Expected cmplx.");
        XSRETURN(1);
    }
    ctanh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_catanh) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: catanh(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of catanh. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of catanh. Expected cmplx.");
        XSRETURN(1);
    }
    catanh(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_cpow) {

    cmplx * _arg0;
    cmplx * _arg1;
    cmplx * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: cpow(a,z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cpow. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cpow. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Complex")) {
        croak("Type error in argument 3 of cpow. Expected cmplx.");
        XSRETURN(1);
    }
    cpow(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_radd) {

    fract * _arg0;
    fract * _arg1;
    fract * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: radd(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of radd. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Fraction")) {
        croak("Type error in argument 2 of radd. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Fraction")) {
        croak("Type error in argument 3 of radd. Expected fract.");
        XSRETURN(1);
    }
    radd(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_rsub) {

    fract * _arg0;
    fract * _arg1;
    fract * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: rsub(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of rsub. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Fraction")) {
        croak("Type error in argument 2 of rsub. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Fraction")) {
        croak("Type error in argument 3 of rsub. Expected fract.");
        XSRETURN(1);
    }
    rsub(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_rmul) {

    fract * _arg0;
    fract * _arg1;
    fract * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: rmul(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of rmul. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Fraction")) {
        croak("Type error in argument 2 of rmul. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Fraction")) {
        croak("Type error in argument 3 of rmul. Expected fract.");
        XSRETURN(1);
    }
    rmul(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_rdiv) {

    fract * _arg0;
    fract * _arg1;
    fract * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: rdiv(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of rdiv. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Fraction")) {
        croak("Type error in argument 2 of rdiv. Expected fract.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Fraction")) {
        croak("Type error in argument 3 of rdiv. Expected fract.");
        XSRETURN(1);
    }
    rdiv(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_euclid) {

    double  _result;
    double * _arg0;
    double * _arg1;
    int argvi = 0;
    double  temp;
    double  temp0;
    SV * _saved[2];
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: euclid(BOTH,BOTH);");
{
  temp = (double) SvNV(ST(0));
  _arg0 = &temp;
}
    _saved[0] = ST(0);
{
  temp0 = (double) SvNV(ST(1));
  _arg1 = &temp0;
}
    _saved[1] = ST(1);
    _result = (double )euclid(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg0));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg1));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_cadd) {

    cmplx * _arg0;
    cmplx * _arg1;
    cmplx * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: cadd(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cadd. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cadd. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Complex")) {
        croak("Type error in argument 3 of cadd. Expected cmplx.");
        XSRETURN(1);
    }
    cadd(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_csub) {

    cmplx * _arg0;
    cmplx * _arg1;
    cmplx * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: csub(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of csub. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of csub. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Complex")) {
        croak("Type error in argument 3 of csub. Expected cmplx.");
        XSRETURN(1);
    }
    csub(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_cmul) {

    cmplx * _arg0;
    cmplx * _arg1;
    cmplx * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: cmul(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cmul. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cmul. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Complex")) {
        croak("Type error in argument 3 of cmul. Expected cmplx.");
        XSRETURN(1);
    }
    cmul(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_cdiv) {

    cmplx * _arg0;
    cmplx * _arg1;
    cmplx * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: cdiv(a,b,c);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cdiv. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of cdiv. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"Math::Cephes::Complex")) {
        croak("Type error in argument 3 of cdiv. Expected cmplx.");
        XSRETURN(1);
    }
    cdiv(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_cmov) {

    void * _arg0;
    void * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cmov(a,b);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of cmov. Expected voidPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of cmov. Expected voidPtr.");
        XSRETURN(1);
    }
    cmov(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_cneg) {

    cmplx * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cneg(a);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cneg. Expected cmplx.");
        XSRETURN(1);
    }
    cneg(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_cabs) {

    double  _result;
    cmplx * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cabs(z);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cabs. Expected cmplx.");
        XSRETURN(1);
    }
    _result = (double )cabs(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_csqrt) {

    cmplx * _arg0;
    cmplx * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: csqrt(z,w);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of csqrt. Expected cmplx.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"Math::Cephes::Complex")) {
        croak("Type error in argument 2 of csqrt. Expected cmplx.");
        XSRETURN(1);
    }
    csqrt(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_hypot) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: hypot(x,y);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )hypot(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cosh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cosh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cosh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_dawsn) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: dawsn(xx);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )dawsn(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ellie) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ellie(phi,m);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )ellie(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ellik) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ellik(phi,m);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )ellik(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ellpe) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ellpe(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ellpe(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ellpj) {

    int  _result;
    double  _arg0;
    double  _arg1;
    double * _arg2;
    double  temp;
    double * _arg3;
    double  temp0;
    double * _arg4;
    double  temp1;
    double * _arg5;
    double  temp2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg2 = &temp;
}
{
  _arg3 = &temp0;
}
{
  _arg4 = &temp1;
}
{
  _arg5 = &temp2;
}
    if ((items < 2) || (items > 2)) 
        croak("Usage: ellpj(u,m);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (int )ellpj(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg2));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg3));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg4));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg5));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ellpk) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ellpk(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ellpk(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_exp) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: exp(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )exp(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_exp10) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: exp10(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )exp10(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_exp2) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: exp2(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )exp2(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_expn) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: expn(n,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )expn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ei) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ei(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ei(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_fabs) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: fabs(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )fabs(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_fac) {

    double  _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: fac(i);");
    _arg0 = (int )SvIV(ST(0));
    _result = (double )fac(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_fdtrc) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: fdtrc(ia,ib,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )fdtrc(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_fdtr) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: fdtr(ia,ib,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )fdtr(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_fdtri) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: fdtri(ia,ib,y);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )fdtri(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ceil) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ceil(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ceil(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_floor) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: floor(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )floor(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_frexp) {

    double  _result;
    double  _arg0;
    int * _arg1;
    int  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg1 = &temp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: frexp(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )frexp(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg1));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ldexp) {

    double  _result;
    double  _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ldexp(x,pw2);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (double )ldexp(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_signbit) {

    int  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: signbit(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )signbit(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_isnan) {

    int  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: isnan(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )isnan(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_isfinite) {

    int  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: isfinite(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )isfinite(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_fresnl) {

    int  _result;
    double  _arg0;
    double * _arg1;
    double  temp;
    double * _arg2;
    double  temp0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg1 = &temp;
}
{
  _arg2 = &temp0;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: fresnl(xxa);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )fresnl(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg1));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg2));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_gamma) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: gamma(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )gamma(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_lgam) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: lgam(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )lgam(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gdtr) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: gdtr(a,b,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )gdtr(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_gdtrc) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: gdtrc(a,b,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )gdtrc(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_hyp2f1) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    double  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: hyp2f1(a,b,c,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (double )hyp2f1(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_hyperg) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: hyperg(a,b,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )hyperg(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_hyp2f0) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int  _arg3;
    double * _arg4;
    double  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg4 = &temp;
}
    if ((items < 4) || (items > 4)) 
        croak("Usage: hyp2f0(a,b,x,type);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _result = (double )hyp2f0(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_i0) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: i0(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )i0(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_i0e) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: i0e(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )i0e(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_i1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: i1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )i1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_i1e) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: i1e(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )i1e(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_igamc) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: igamc(a,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )igamc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_igam) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: igam(a,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )igam(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_igami) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: igami(a,y0);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )igami(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_incbet) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: incbet(aa,bb,xx);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )incbet(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_incbi) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: incbi(aa,bb,yy0);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )incbi(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_iv) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: iv(v,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )iv(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_j0) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: j0(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )j0(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_y0) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: y0(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )y0(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_j1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: j1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )j1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_y1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: y1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )y1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_jn) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: jn(n,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )jn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_jv) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: jv(n,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )jv(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_k0) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: k0(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )k0(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_k0e) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: k0e(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )k0e(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_k1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: k1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )k1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_k1e) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: k1e(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )k1e(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_kn) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: kn(nn,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )kn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_log) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: log(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )log(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_log10) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: log10(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )log10(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_log2) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: log2(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )log2(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_lrand) {

    long  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: lrand();");
    _result = (long )lrand();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_lsqrt) {

    long  _result;
    long  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: lsqrt(x);");
    _arg0 = (long )SvIV(ST(0));
    _result = (long )lsqrt(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_mtherr) {

    int  _result;
    char * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: mtherr(name,code);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )mtherr(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_polevl) {

    double  _result;
    double  _arg0;
    void * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: polevl(x,P,N);");
    _arg0 = (double ) SvNV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of polevl. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )polevl(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_p1evl) {

    double  _result;
    double  _arg0;
    void * _arg1;
    int  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: p1evl(x,P,N);");
    _arg0 = (double ) SvNV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,(char *) 0 )) {
        croak("Type error in argument 2 of p1evl. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )p1evl(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_nbdtrc) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: nbdtrc(k,n,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )nbdtrc(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_nbdtr) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: nbdtr(k,n,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )nbdtr(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_nbdtri) {

    double  _result;
    int  _arg0;
    int  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: nbdtri(k,n,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )nbdtri(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ndtr) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ndtr(a);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ndtr(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_erfc) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: erfc(a);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )erfc(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_erf) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: erf(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )erf(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_ndtri) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ndtri(y0);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )ndtri(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_pdtrc) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pdtrc(k,m);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )pdtrc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_pdtr) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pdtr(k,m);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )pdtr(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_pdtri) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pdtri(k,y);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )pdtri(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_pow) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pow(x,y);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )pow(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_powi) {

    double  _result;
    double  _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: powi(x,nn);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (double )powi(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_psi) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: psi(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )psi(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_rgamma) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: rgamma(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )rgamma(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_round) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: round(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )round(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_shichi) {

    int  _result;
    double  _arg0;
    double * _arg1;
    double  temp;
    double * _arg2;
    double  temp0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg1 = &temp;
}
{
  _arg2 = &temp0;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: shichi(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )shichi(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg1));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg2));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_sici) {

    int  _result;
    double  _arg0;
    double * _arg1;
    double  temp;
    double * _arg2;
    double  temp0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg1 = &temp;
}
{
  _arg2 = &temp0;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: sici(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )sici(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg1));
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg2));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_sin) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: sin(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )sin(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cos) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cos(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cos(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_radian) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: radian(d,m,s);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (double )radian(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_sindg) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: sindg(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )sindg(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cosdg) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cosdg(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cosdg(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_sinh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: sinh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )sinh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_spence) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: spence(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )spence(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_sqrt) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: sqrt(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )sqrt(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_stdtr) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: stdtr(k,t);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )stdtr(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_stdtri) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: stdtri(k,p);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )stdtri(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_onef2) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    double  _arg3;
    double * _arg4;
    double  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg4 = &temp;
}
    if ((items < 4) || (items > 4)) 
        croak("Usage: onef2(a,b,c,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (double )onef2(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_threef0) {

    double  _result;
    double  _arg0;
    double  _arg1;
    double  _arg2;
    double  _arg3;
    double * _arg4;
    double  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg4 = &temp;
}
    if ((items < 4) || (items > 4)) 
        croak("Usage: threef0(a,b,c,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (double )threef0(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_struve) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: struve(v,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )struve(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_tan) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: tan(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )tan(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cot) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cot(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cot(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_tandg) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: tandg(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )tandg(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cotdg) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cotdg(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cotdg(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_tanh) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: tanh(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )tanh(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_log1p) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: log1p(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )log1p(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_expm1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: expm1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )expm1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_cosm1) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cosm1(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )cosm1(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_yn) {

    double  _result;
    int  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: yn(n,x);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )yn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_yv) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: yv(n,x);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )yv(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_zeta) {

    double  _result;
    double  _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: zeta(x,q);");
    _arg0 = (double ) SvNV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )zeta(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_zetac) {

    double  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: zetac(x);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (double )zetac(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_drand) {

    int  _result;
    double * _arg0;
    double  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
  _arg0 = &temp;
}
    if ((items < 0) || (items > 0)) 
        croak("Usage: drand();");
    _result = (int )drand(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setnv(ST(argvi),(double) *(_arg0));
  argvi++;
}
    XSRETURN(argvi);
}

#define cmplx_r_set(_swigobj,_swigval) (_swigobj->r = _swigval,_swigval)
XS(_wrap_cmplx_r_set) {

    double  _result;
    cmplx * _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cmplx_r_set(self,r);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cmplx_r_set. Expected cmplx.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )cmplx_r_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define cmplx_r_get(_swigobj) ((double ) _swigobj->r)
XS(_wrap_cmplx_r_get) {

    double  _result;
    cmplx * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cmplx_r_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cmplx_r_get. Expected cmplx.");
        XSRETURN(1);
    }
    _result = (double )cmplx_r_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define cmplx_i_set(_swigobj,_swigval) (_swigobj->i = _swigval,_swigval)
XS(_wrap_cmplx_i_set) {

    double  _result;
    cmplx * _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: cmplx_i_set(self,i);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cmplx_i_set. Expected cmplx.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )cmplx_i_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define cmplx_i_get(_swigobj) ((double ) _swigobj->i)
XS(_wrap_cmplx_i_get) {

    double  _result;
    cmplx * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: cmplx_i_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of cmplx_i_get. Expected cmplx.");
        XSRETURN(1);
    }
    _result = (double )cmplx_i_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

static cmplx *new_cmplx(double r,double i) {
   	    cmplx *c;
  	    c = (cmplx *) malloc(sizeof(cmplx));
    	    c->r = r;
    	    c->i = i;
    	    return c;
	  }

XS(_wrap_new_cmplx) {

    cmplx * _result;
    double  _arg0 = (double ) 0;
    double  _arg1 = (double ) 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 2)) 
        croak("Usage: new_cmplx(r,i);");
    if (items > 0) {
    _arg0 = (double ) SvNV(ST(0));
    } 
    if (items > 1) {
    _arg1 = (double ) SvNV(ST(1));
    } 
    _result = (cmplx *)new_cmplx(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"Math::Cephes::Complex", (void *) _result);
    XSRETURN(argvi);
}

static void delete_cmplx(cmplx *self) {
	    free(self);
	  }
XS(_wrap_delete_cmplx) {

    cmplx * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: delete_cmplx(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Complex")) {
        croak("Type error in argument 1 of delete_cmplx. Expected cmplx.");
        XSRETURN(1);
    }
    delete_cmplx(_arg0);
    XSRETURN(argvi);
}

#define fract_n_set(_swigobj,_swigval) (_swigobj->n = _swigval,_swigval)
XS(_wrap_fract_n_set) {

    double  _result;
    fract * _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: fract_n_set(self,n);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of fract_n_set. Expected fract.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )fract_n_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define fract_n_get(_swigobj) ((double ) _swigobj->n)
XS(_wrap_fract_n_get) {

    double  _result;
    fract * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: fract_n_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of fract_n_get. Expected fract.");
        XSRETURN(1);
    }
    _result = (double )fract_n_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define fract_d_set(_swigobj,_swigval) (_swigobj->d = _swigval,_swigval)
XS(_wrap_fract_d_set) {

    double  _result;
    fract * _arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: fract_d_set(self,d);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of fract_d_set. Expected fract.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _result = (double )fract_d_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define fract_d_get(_swigobj) ((double ) _swigobj->d)
XS(_wrap_fract_d_get) {

    double  _result;
    fract * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: fract_d_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of fract_d_get. Expected fract.");
        XSRETURN(1);
    }
    _result = (double )fract_d_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

static fract *new_fract(double n,double d) {
   	    fract *f;
  	    f = (fract *) malloc(sizeof(fract));
    	    f->n = n;
    	    f->d = d;
    	    return f;
	  }

XS(_wrap_new_fract) {

    fract * _result;
    double  _arg0 = (double ) 0;
    double  _arg1 = (double ) 1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 2)) 
        croak("Usage: new_fract(n,d);");
    if (items > 0) {
    _arg0 = (double ) SvNV(ST(0));
    } 
    if (items > 1) {
    _arg1 = (double ) SvNV(ST(1));
    } 
    _result = (fract *)new_fract(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"Math::Cephes::Fraction", (void *) _result);
    XSRETURN(argvi);
}

static void delete_fract(fract *self) {
	    free(self);
	  }
XS(_wrap_delete_fract) {

    fract * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: delete_fract(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"Math::Cephes::Fraction")) {
        croak("Type error in argument 1 of delete_fract. Expected fract.");
        XSRETURN(1);
    }
    delete_fract(_arg0);
    XSRETURN(argvi);
}

/*
 * This table is used by the pointer type-checker
 */
static struct { char *n1; char *n2; void *(*pcnv)(void *); } _swig_mapping[] = {
    { "unsigned short","short",0},
    { "long","unsigned long",0},
    { "long","signed long",0},
    { "signed short","short",0},
    { "signed int","int",0},
    { "short","unsigned short",0},
    { "short","signed short",0},
    { "unsigned long","long",0},
    { "int","unsigned int",0},
    { "int","signed int",0},
    { "unsigned int","int",0},
    { "signed long","long",0},
{0,0,0}};

XS(_wrap_perl5_Math__Cephes_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    sv = perl_get_sv("Math::Cephes::MACHEP",TRUE | 0x2);
    sv_setnv(sv,(double)MACHEP);
    swig_create_magic(sv,"Math::Cephes::MACHEP", MAGIC_CAST MAGIC_CLASS _wrap_set_MACHEP, MAGIC_CAST MAGIC_CLASS _wrap_val_MACHEP);
    sv = perl_get_sv("Math::Cephes::MAXLOG",TRUE | 0x2);
    sv_setnv(sv,(double)MAXLOG);
    swig_create_magic(sv,"Math::Cephes::MAXLOG", MAGIC_CAST MAGIC_CLASS _wrap_set_MAXLOG, MAGIC_CAST MAGIC_CLASS _wrap_val_MAXLOG);
    sv = perl_get_sv("Math::Cephes::MINLOG",TRUE | 0x2);
    sv_setnv(sv,(double)MINLOG);
    swig_create_magic(sv,"Math::Cephes::MINLOG", MAGIC_CAST MAGIC_CLASS _wrap_set_MINLOG, MAGIC_CAST MAGIC_CLASS _wrap_val_MINLOG);
    sv = perl_get_sv("Math::Cephes::MAXNUM",TRUE | 0x2);
    sv_setnv(sv,(double)MAXNUM);
    swig_create_magic(sv,"Math::Cephes::MAXNUM", MAGIC_CAST MAGIC_CLASS _wrap_set_MAXNUM, MAGIC_CAST MAGIC_CLASS _wrap_val_MAXNUM);
    sv = perl_get_sv("Math::Cephes::PI",TRUE | 0x2);
    sv_setnv(sv,(double)PI);
    swig_create_magic(sv,"Math::Cephes::PI", MAGIC_CAST MAGIC_CLASS _wrap_set_PI, MAGIC_CAST MAGIC_CLASS _wrap_val_PI);
    sv = perl_get_sv("Math::Cephes::PIO2",TRUE | 0x2);
    sv_setnv(sv,(double)PIO2);
    swig_create_magic(sv,"Math::Cephes::PIO2", MAGIC_CAST MAGIC_CLASS _wrap_set_PIO2, MAGIC_CAST MAGIC_CLASS _wrap_val_PIO2);
    sv = perl_get_sv("Math::Cephes::PIO4",TRUE | 0x2);
    sv_setnv(sv,(double)PIO4);
    swig_create_magic(sv,"Math::Cephes::PIO4", MAGIC_CAST MAGIC_CLASS _wrap_set_PIO4, MAGIC_CAST MAGIC_CLASS _wrap_val_PIO4);
    sv = perl_get_sv("Math::Cephes::SQRT2",TRUE | 0x2);
    sv_setnv(sv,(double)SQRT2);
    swig_create_magic(sv,"Math::Cephes::SQRT2", MAGIC_CAST MAGIC_CLASS _wrap_set_SQRT2, MAGIC_CAST MAGIC_CLASS _wrap_val_SQRT2);
    sv = perl_get_sv("Math::Cephes::SQRTH",TRUE | 0x2);
    sv_setnv(sv,(double)SQRTH);
    swig_create_magic(sv,"Math::Cephes::SQRTH", MAGIC_CAST MAGIC_CLASS _wrap_set_SQRTH, MAGIC_CAST MAGIC_CLASS _wrap_val_SQRTH);
    sv = perl_get_sv("Math::Cephes::LOG2E",TRUE | 0x2);
    sv_setnv(sv,(double)LOG2E);
    swig_create_magic(sv,"Math::Cephes::LOG2E", MAGIC_CAST MAGIC_CLASS _wrap_set_LOG2E, MAGIC_CAST MAGIC_CLASS _wrap_val_LOG2E);
    sv = perl_get_sv("Math::Cephes::SQ2OPI",TRUE | 0x2);
    sv_setnv(sv,(double)SQ2OPI);
    swig_create_magic(sv,"Math::Cephes::SQ2OPI", MAGIC_CAST MAGIC_CLASS _wrap_set_SQ2OPI, MAGIC_CAST MAGIC_CLASS _wrap_val_SQ2OPI);
    sv = perl_get_sv("Math::Cephes::LOGE2",TRUE | 0x2);
    sv_setnv(sv,(double)LOGE2);
    swig_create_magic(sv,"Math::Cephes::LOGE2", MAGIC_CAST MAGIC_CLASS _wrap_set_LOGE2, MAGIC_CAST MAGIC_CLASS _wrap_val_LOGE2);
    sv = perl_get_sv("Math::Cephes::LOGSQ2",TRUE | 0x2);
    sv_setnv(sv,(double)LOGSQ2);
    swig_create_magic(sv,"Math::Cephes::LOGSQ2", MAGIC_CAST MAGIC_CLASS _wrap_set_LOGSQ2, MAGIC_CAST MAGIC_CLASS _wrap_val_LOGSQ2);
    sv = perl_get_sv("Math::Cephes::THPIO4",TRUE | 0x2);
    sv_setnv(sv,(double)THPIO4);
    swig_create_magic(sv,"Math::Cephes::THPIO4", MAGIC_CAST MAGIC_CLASS _wrap_set_THPIO4, MAGIC_CAST MAGIC_CLASS _wrap_val_THPIO4);
    sv = perl_get_sv("Math::Cephes::TWOOPI",TRUE | 0x2);
    sv_setnv(sv,(double)TWOOPI);
    swig_create_magic(sv,"Math::Cephes::TWOOPI", MAGIC_CAST MAGIC_CLASS _wrap_set_TWOOPI, MAGIC_CAST MAGIC_CLASS _wrap_val_TWOOPI);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_Math__Cephes) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("Math::Cephes::var_Math__Cephes_init", _wrap_perl5_Math__Cephes_var_init, file);
	 newXS("Math::Cephes::acosh", _wrap_acosh, file);
	 newXS("Math::Cephes::airy", _wrap_airy, file);
	 newXS("Math::Cephes::asin", _wrap_asin, file);
	 newXS("Math::Cephes::acos", _wrap_acos, file);
	 newXS("Math::Cephes::asinh", _wrap_asinh, file);
	 newXS("Math::Cephes::atan", _wrap_atan, file);
	 newXS("Math::Cephes::atan2", _wrap_atan2, file);
	 newXS("Math::Cephes::atanh", _wrap_atanh, file);
	 newXS("Math::Cephes::bdtrc", _wrap_bdtrc, file);
	 newXS("Math::Cephes::bdtr", _wrap_bdtr, file);
	 newXS("Math::Cephes::bdtri", _wrap_bdtri, file);
	 newXS("Math::Cephes::beta", _wrap_beta, file);
	 newXS("Math::Cephes::lbeta", _wrap_lbeta, file);
	 newXS("Math::Cephes::btdtr", _wrap_btdtr, file);
	 newXS("Math::Cephes::cbrt", _wrap_cbrt, file);
	 newXS("Math::Cephes::chbevl", _wrap_chbevl, file);
	 newXS("Math::Cephes::chdtrc", _wrap_chdtrc, file);
	 newXS("Math::Cephes::chdtr", _wrap_chdtr, file);
	 newXS("Math::Cephes::chdtri", _wrap_chdtri, file);
	 newXS("Math::Cephes::clog", _wrap_clog, file);
	 newXS("Math::Cephes::cexp", _wrap_cexp, file);
	 newXS("Math::Cephes::csin", _wrap_csin, file);
	 newXS("Math::Cephes::ccos", _wrap_ccos, file);
	 newXS("Math::Cephes::ctan", _wrap_ctan, file);
	 newXS("Math::Cephes::ccot", _wrap_ccot, file);
	 newXS("Math::Cephes::casin", _wrap_casin, file);
	 newXS("Math::Cephes::cacos", _wrap_cacos, file);
	 newXS("Math::Cephes::catan", _wrap_catan, file);
	 newXS("Math::Cephes::csinh", _wrap_csinh, file);
	 newXS("Math::Cephes::casinh", _wrap_casinh, file);
	 newXS("Math::Cephes::ccosh", _wrap_ccosh, file);
	 newXS("Math::Cephes::cacosh", _wrap_cacosh, file);
	 newXS("Math::Cephes::ctanh", _wrap_ctanh, file);
	 newXS("Math::Cephes::catanh", _wrap_catanh, file);
	 newXS("Math::Cephes::cpow", _wrap_cpow, file);
	 newXS("Math::Cephes::radd", _wrap_radd, file);
	 newXS("Math::Cephes::rsub", _wrap_rsub, file);
	 newXS("Math::Cephes::rmul", _wrap_rmul, file);
	 newXS("Math::Cephes::rdiv", _wrap_rdiv, file);
	 newXS("Math::Cephes::euclid", _wrap_euclid, file);
	 newXS("Math::Cephes::cadd", _wrap_cadd, file);
	 newXS("Math::Cephes::csub", _wrap_csub, file);
	 newXS("Math::Cephes::cmul", _wrap_cmul, file);
	 newXS("Math::Cephes::cdiv", _wrap_cdiv, file);
	 newXS("Math::Cephes::cmov", _wrap_cmov, file);
	 newXS("Math::Cephes::cneg", _wrap_cneg, file);
	 newXS("Math::Cephes::cabs", _wrap_cabs, file);
	 newXS("Math::Cephes::csqrt", _wrap_csqrt, file);
	 newXS("Math::Cephes::hypot", _wrap_hypot, file);
	 newXS("Math::Cephes::cosh", _wrap_cosh, file);
	 newXS("Math::Cephes::dawsn", _wrap_dawsn, file);
	 newXS("Math::Cephes::ellie", _wrap_ellie, file);
	 newXS("Math::Cephes::ellik", _wrap_ellik, file);
	 newXS("Math::Cephes::ellpe", _wrap_ellpe, file);
	 newXS("Math::Cephes::ellpj", _wrap_ellpj, file);
	 newXS("Math::Cephes::ellpk", _wrap_ellpk, file);
	 newXS("Math::Cephes::exp", _wrap_exp, file);
	 newXS("Math::Cephes::exp10", _wrap_exp10, file);
	 newXS("Math::Cephes::exp2", _wrap_exp2, file);
	 newXS("Math::Cephes::expn", _wrap_expn, file);
	 newXS("Math::Cephes::ei", _wrap_ei, file);
	 newXS("Math::Cephes::fabs", _wrap_fabs, file);
	 newXS("Math::Cephes::fac", _wrap_fac, file);
	 newXS("Math::Cephes::fdtrc", _wrap_fdtrc, file);
	 newXS("Math::Cephes::fdtr", _wrap_fdtr, file);
	 newXS("Math::Cephes::fdtri", _wrap_fdtri, file);
	 newXS("Math::Cephes::ceil", _wrap_ceil, file);
	 newXS("Math::Cephes::floor", _wrap_floor, file);
	 newXS("Math::Cephes::frexp", _wrap_frexp, file);
	 newXS("Math::Cephes::ldexp", _wrap_ldexp, file);
	 newXS("Math::Cephes::signbit", _wrap_signbit, file);
	 newXS("Math::Cephes::isnan", _wrap_isnan, file);
	 newXS("Math::Cephes::isfinite", _wrap_isfinite, file);
	 newXS("Math::Cephes::fresnl", _wrap_fresnl, file);
	 newXS("Math::Cephes::gamma", _wrap_gamma, file);
	 newXS("Math::Cephes::lgam", _wrap_lgam, file);
	 newXS("Math::Cephes::gdtr", _wrap_gdtr, file);
	 newXS("Math::Cephes::gdtrc", _wrap_gdtrc, file);
	 newXS("Math::Cephes::hyp2f1", _wrap_hyp2f1, file);
	 newXS("Math::Cephes::hyperg", _wrap_hyperg, file);
	 newXS("Math::Cephes::hyp2f0", _wrap_hyp2f0, file);
	 newXS("Math::Cephes::i0", _wrap_i0, file);
	 newXS("Math::Cephes::i0e", _wrap_i0e, file);
	 newXS("Math::Cephes::i1", _wrap_i1, file);
	 newXS("Math::Cephes::i1e", _wrap_i1e, file);
	 newXS("Math::Cephes::igamc", _wrap_igamc, file);
	 newXS("Math::Cephes::igam", _wrap_igam, file);
	 newXS("Math::Cephes::igami", _wrap_igami, file);
	 newXS("Math::Cephes::incbet", _wrap_incbet, file);
	 newXS("Math::Cephes::incbi", _wrap_incbi, file);
	 newXS("Math::Cephes::iv", _wrap_iv, file);
	 newXS("Math::Cephes::j0", _wrap_j0, file);
	 newXS("Math::Cephes::y0", _wrap_y0, file);
	 newXS("Math::Cephes::j1", _wrap_j1, file);
	 newXS("Math::Cephes::y1", _wrap_y1, file);
	 newXS("Math::Cephes::jn", _wrap_jn, file);
	 newXS("Math::Cephes::jv", _wrap_jv, file);
	 newXS("Math::Cephes::k0", _wrap_k0, file);
	 newXS("Math::Cephes::k0e", _wrap_k0e, file);
	 newXS("Math::Cephes::k1", _wrap_k1, file);
	 newXS("Math::Cephes::k1e", _wrap_k1e, file);
	 newXS("Math::Cephes::kn", _wrap_kn, file);
	 newXS("Math::Cephes::log", _wrap_log, file);
	 newXS("Math::Cephes::log10", _wrap_log10, file);
	 newXS("Math::Cephes::log2", _wrap_log2, file);
	 newXS("Math::Cephes::lrand", _wrap_lrand, file);
	 newXS("Math::Cephes::lsqrt", _wrap_lsqrt, file);
	 newXS("Math::Cephes::mtherr", _wrap_mtherr, file);
	 newXS("Math::Cephes::polevl", _wrap_polevl, file);
	 newXS("Math::Cephes::p1evl", _wrap_p1evl, file);
	 newXS("Math::Cephes::nbdtrc", _wrap_nbdtrc, file);
	 newXS("Math::Cephes::nbdtr", _wrap_nbdtr, file);
	 newXS("Math::Cephes::nbdtri", _wrap_nbdtri, file);
	 newXS("Math::Cephes::ndtr", _wrap_ndtr, file);
	 newXS("Math::Cephes::erfc", _wrap_erfc, file);
	 newXS("Math::Cephes::erf", _wrap_erf, file);
	 newXS("Math::Cephes::ndtri", _wrap_ndtri, file);
	 newXS("Math::Cephes::pdtrc", _wrap_pdtrc, file);
	 newXS("Math::Cephes::pdtr", _wrap_pdtr, file);
	 newXS("Math::Cephes::pdtri", _wrap_pdtri, file);
	 newXS("Math::Cephes::pow", _wrap_pow, file);
	 newXS("Math::Cephes::powi", _wrap_powi, file);
	 newXS("Math::Cephes::psi", _wrap_psi, file);
	 newXS("Math::Cephes::rgamma", _wrap_rgamma, file);
	 newXS("Math::Cephes::round", _wrap_round, file);
	 newXS("Math::Cephes::shichi", _wrap_shichi, file);
	 newXS("Math::Cephes::sici", _wrap_sici, file);
	 newXS("Math::Cephes::sin", _wrap_sin, file);
	 newXS("Math::Cephes::cos", _wrap_cos, file);
	 newXS("Math::Cephes::radian", _wrap_radian, file);
	 newXS("Math::Cephes::sindg", _wrap_sindg, file);
	 newXS("Math::Cephes::cosdg", _wrap_cosdg, file);
	 newXS("Math::Cephes::sinh", _wrap_sinh, file);
	 newXS("Math::Cephes::spence", _wrap_spence, file);
	 newXS("Math::Cephes::sqrt", _wrap_sqrt, file);
	 newXS("Math::Cephes::stdtr", _wrap_stdtr, file);
	 newXS("Math::Cephes::stdtri", _wrap_stdtri, file);
	 newXS("Math::Cephes::onef2", _wrap_onef2, file);
	 newXS("Math::Cephes::threef0", _wrap_threef0, file);
	 newXS("Math::Cephes::struve", _wrap_struve, file);
	 newXS("Math::Cephes::tan", _wrap_tan, file);
	 newXS("Math::Cephes::cot", _wrap_cot, file);
	 newXS("Math::Cephes::tandg", _wrap_tandg, file);
	 newXS("Math::Cephes::cotdg", _wrap_cotdg, file);
	 newXS("Math::Cephes::tanh", _wrap_tanh, file);
	 newXS("Math::Cephes::log1p", _wrap_log1p, file);
	 newXS("Math::Cephes::expm1", _wrap_expm1, file);
	 newXS("Math::Cephes::cosm1", _wrap_cosm1, file);
	 newXS("Math::Cephes::yn", _wrap_yn, file);
	 newXS("Math::Cephes::yv", _wrap_yv, file);
	 newXS("Math::Cephes::zeta", _wrap_zeta, file);
	 newXS("Math::Cephes::zetac", _wrap_zetac, file);
	 newXS("Math::Cephes::drand", _wrap_drand, file);
	 newXS("Math::Cephes::cmplx_r_set", _wrap_cmplx_r_set, file);
	 newXS("Math::Cephes::cmplx_r_get", _wrap_cmplx_r_get, file);
	 newXS("Math::Cephes::cmplx_i_set", _wrap_cmplx_i_set, file);
	 newXS("Math::Cephes::cmplx_i_get", _wrap_cmplx_i_get, file);
	 newXS("Math::Cephes::new_cmplx", _wrap_new_cmplx, file);
	 newXS("Math::Cephes::delete_cmplx", _wrap_delete_cmplx, file);
	 newXS("Math::Cephes::fract_n_set", _wrap_fract_n_set, file);
	 newXS("Math::Cephes::fract_n_get", _wrap_fract_n_get, file);
	 newXS("Math::Cephes::fract_d_set", _wrap_fract_d_set, file);
	 newXS("Math::Cephes::fract_d_get", _wrap_fract_d_get, file);
	 newXS("Math::Cephes::new_fract", _wrap_new_fract, file);
	 newXS("Math::Cephes::delete_fract", _wrap_delete_fract, file);
{
   int i;
   for (i = 0; _swig_mapping[i].n1; i++)
        SWIG_RegisterMapping(_swig_mapping[i].n1,_swig_mapping[i].n2,_swig_mapping[i].pcnv);
}
	 ST(0) = &PL_sv_yes;
	 XSRETURN(1);
}
